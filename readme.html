<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.40">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Javier Zialcita">
<meta name="description" content="An analysis of Arsenal’s attacking performance in the 2024/25 Premier League season, focusing on shot creation, chance quality, and tactical trends.">

<title>Arsenal 2024/25 Shot Analysis Report</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="readme_files/libs/clipboard/clipboard.min.js"></script>
<script src="readme_files/libs/quarto-html/quarto.js"></script>
<script src="readme_files/libs/quarto-html/popper.min.js"></script>
<script src="readme_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="readme_files/libs/quarto-html/anchor.min.js"></script>
<link href="readme_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="readme_files/libs/quarto-html/quarto-syntax-highlighting-549806ee2085284f45b00abea8c6df48.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="readme_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="readme_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="readme_files/libs/bootstrap/bootstrap-8a79a254b8e706d3c925cde0a310d4f0.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">


</head>

<body class="fullcontent">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Arsenal 2024/25 Shot Analysis Report</h1>
</div>

<div>
  <div class="description">
    An analysis of Arsenal’s attacking performance in the 2024/25 Premier League season, focusing on shot creation, chance quality, and tactical trends.
  </div>
</div>


<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Javier Zialcita </p>
          </div>
  </div>
    
  
    
  </div>
  


</header>


<section id="motivation-goal" class="level1">
<h1>Motivation / Goal</h1>
<p>I created this project to put the skills I’ve learned through my classes at Cal Poly towards a topic I’m really passionate about and hope to pursue in the future. I’ve been supporting Arsenal Football Club since I was 7 years old and after a frustrating season, I wanted to test myself to see if I could reach some conclusions using the main programming language I’ve learned through my classes in pursuit of a statistics degree.</p>
<p>Analysts of soccer base their reports off of this. As for the coaching and recruiting staff at Arsenal, I would’ve shown this report to them at the start of the transfer window back in June to guide them towards how they can improve their tactics, or get different players that can achieve the playstyle necessary to improve. However, people that aren’t involved in the sport professionally can still read this to gain an understanding of Arsenal’s strengths and weaknesses.</p>
</section>
<section id="features" class="level1">
<h1>Features</h1>
<p>Data cleaning and preparation: Processes Arsenal’s 2024/25 shot data (arsenal_24_25.csv), including filtering, recoding variables, and adding derived features like player_beaten and side.</p>
<p>Shot outcome summaries: Breaks down results of shots (goal, saved, blocked, off target) and assist types (cross, through ball, cutback, set piece).</p>
<p>Statistical testing: Uses t-tests, Wilcoxon tests, chi-square tests, and logistic regression to explore how pressure, dribbling, angle, and shot type affect chance quality and scoring.</p>
<p>Visualizations: Produces charts showing shot zones, set piece reliance, and outcome distributions to make findings easy to see.</p>
<p>Narrative explanations: Translates statistical results into plain language so even readers who don’t watch soccer can follow the story.</p>
<p>Future adaptability: Regression model can be applied to future datasets to predict scoring likelihood under different conditions.</p>
<p>I got all the data manually, by going through all 38 Arsenal game highlights on Youtube.</p>
<section id="data" class="level2">
<h2 class="anchored" data-anchor-id="data">Data</h2>
<p>The dataset <code>arsenal_24_25.csv</code> contains one row per Arsenal shot in the 2024/25 season. All the variables are described below</p>
<ul>
<li><code>date</code> → Date of the match when shot was taken</li>
<li><code>matchday</code> → the round of the league season in which the game was played</li>
<li><code>opponent</code> → the team that the shot was against</li>
<li><code>minute</code>→ the minute the shot was taken in the match</li>
<li><code>time_of_shot_after_entry</code> → how many seconds pass between Arsenal moving the ball into the attacking area near the opponent’s goal and when they shoot</li>
<li><code>player</code> → player who takes the shot</li>
<li><code>result</code> → Shot outcome (goal, saved, blocked, off target, deflected off target, own goal)<br>
</li>
<li><code>xg</code> → a number that measures the quality of a shot by estimating how likely it is to become a goal</li>
<li><code>body_part</code> → body part used to shoot (right, left, head, other</li>
<li>’dominant_foot` → whether the shooter used their dominant foot or not</li>
<li><code>final_third_entry</code> → area/method in which the ball entered the final third - “left halfspace” → area between the left and middle columns of the field - “right halfspace” → area between the right and middle columns of the field - “right corner” → corner kick taken from right side of the field - “left corner” → corner kick taken from the left side of the field - “direct freekick” → pass from a free kick awarded by the referee after a foul</li>
<li><code>entry_method</code> → method used to enter the final third</li>
<li><code>type_of_attack</code> → whether the shot came from transitional play, positional play, or a set piece</li>
<li><code>pre_assist</code> → which player passed it to the player who passed to the shooter</li>
<li>‘pre_assist_type’ → how the pre assister passed to the assister</li>
<li><code>assisted_by</code> → player who passed it to the shooter</li>
<li><code>assist_type</code> → how the assister passed to the shooter</li>
<li><code>shot_type</code> → type of shot the shooter took - “normal” → a normal driven shot - “header” → a shot taken with the head while the ball is in the air - “finesse” → a curved shot with the inside of the foot - “volley” → a shot taken with the feet while the ball is in the air - “free kick” → a direct shot from a free kick situation outside the box</li>
<li><code>touches_before_shot</code> → the number of times the shooter touches the ball before taking his shot after receiving the ball</li>
<li><code>zone</code> → the area in which the shot was taken (refer to the figure given below)</li>
<li><code>distance</code> → the distance from goal when the shot was taken</li>
<li><code>shot_angle</code> → how much of the goal the shooter can see when they take the shot. - “straight” → the shooter is directly in front of the goal - “wide” → the shooter is off to the side - “narrow” → the shooter is closer to the end line at a very tight angle</li>
<li><code>beaten_by</code> → the player that gets past a defender on the dribble leading up to the shot</li>
<li><code>linkup_play</code> → whether or not there was quick and intricate passing between the lines before the goal</li>
<li><code>shot_under_pressure</code> → whether or not the opposition defender is close enough to the shooter to affect his shot</li>
<li><code>defenders_between</code> → how many defenders are directly between the shooter and the goal</li>
<li><code>defensive_line</code> → the defensive style of the opponents - “low” → the opponents defend deep in their own half remaining very compact - “mid” → the opponents try to control the middle of the field, limiting the offense from entering the final third - “high” → the opponents press the offense in their own half, trying to win the ball and score right away</li>
<li><code>numbers_in_box</code> → how many defensive players are in the 18 yard box at the time of shot, excluding the goalkeeper</li>
<li><code>transition</code> → whether or not the shot resulted from an Arsenal transition from defense to attack</li>
<li><code>defensive_error</code> → whether or not the defense made an error leading up to the shot</li>
<li><code>opponent_formation</code> → what formation the opponent lined up with</li>
</ul>
</section>
</section>
<section id="installation-requirements" class="level1">
<h1>Installation / Requirements</h1>
<p>This project required the following packages - readr - tidyverse - ggplot</p>
</section>
<section id="usage" class="level1">
<h1>Usage</h1>
<div class="cell">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(quarto)</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>quarto<span class="sc">::</span><span class="fu">quarto_render</span>(<span class="st">"Arsenal Report.qmd"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p><strong>View the report:</strong> <a href="Arsenal%20Report.html">Arsenal Report (HTML)</a></p>
</section>
<section id="key-findings" class="level1">
<h1>Key Findings</h1>
<p>Shot efficiency: Arsenal generated 291 open-play shots and converted 63 of them (about an 18% success rate). Most of these looks came from central areas inside the box.</p>
<p>Pressure impact: When defenders applied pressure, Arsenal’s shots dropped to an average xG of 0.14. Without pressure, that number nearly doubled to 0.24. Pressure clearly reduced the quality of chances.</p>
<p>Set piece reliance: 22% of goals came from set pieces. For a team that should be controlling open play, that’s a high number and shows how often Arsenal leaned on dead-ball situations to score.</p>
<p>Wing imbalance: The attack tilted heavily to the right side through Saka and Ødegaard. Even though he missed half the season, Saka still accounted for about 30% of successful dribbles. On the left, Martinelli and Trossard weren’t nearly as effective, leaving the attack lopsided.</p>
<p>Dribbling threat: Around 22% of all shots and goals came right after a player beat a defender one-on-one. That’s a huge share and shows how dangerous Arsenal can be when someone breaks a line. With stronger wide players, this could become a consistent weapon.</p>
</section>
<section id="setbacks" class="level1">
<h1>Setbacks</h1>
<ul>
<li>small sample sizes for certain shot types and situations</li>
<li>tedious to create this dataset myself by watching videos, ideally I’d have more resources like the professionals do</li>
<li>some variables such as time_of_shot_after_entry, defensive_line, and defenders_between were up to interpretation and weren’t exact</li>
<li>some results weren’t statistically significant, but they still highlighted patterns (such as imbalance between wings) that are meaningful for tactical analysis</li>
</ul>
</section>
<section id="future-work" class="level1">
<h1>Future Work</h1>
<ul>
<li>add some kind of defensive analysis</li>
<li>add player level breakdowns using websites and webscraping</li>
<li>visualization upgrades such as heatmaps or pitch control</li>
<li>build a fitted model and apply it to data from a different season or team</li>
</ul>
</section>
<section id="acknowledgements" class="level1">
<h1>Acknowledgements</h1>
<p>Thank you to Understat for providing xg data and the opensource tools and libraries in R. Special thanks to the Arsenal community and YouTube highlights for making manual data collection possible.</p>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>